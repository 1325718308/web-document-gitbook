# 前端面试汇总
## 字节跳动
### 前端跨域
### 什么是跨域/什么情况下会产生跨域？（同源策略/非同源策略）
* 同源策略
    - 端口、协议、域名相同
* 非同源策略：
    - 端口、协议、域名三者有一个不同
    - 例如：web服务器地址：http://127.0.0.1:3000/index.html
           数据接口地址：http://127.0.0.1:4000/list

跨域是指域名、端口号、协议三者只要有一个不同就会产生跨域。
### 你是如何解决前端跨域的问题？
1、使用JSONP (回调函数方式，需要服务端支持)
JSONP主要是通过带有是scr属性的的标签来实现的跨域，比如script、img、link、iframe等等。具体的实现方式是把我们要请求的服务器（接口）地址放在scr属性的值上面，并且在请求地址后面拼接一个参数，这个参数的值是我们在本地定义的一个方法。当服务器拿到这个参后把客户端所要的数据传入这个参数对应的回调方法内，其实相当于执行了这个回调方法。这时候客户端就可以在这个方法内处理逻辑了。例如下面的方法：

```
    <script src="http://127.0.0.1:4000/list?callback=getData"></script>
    <script>
        function getData(res) {
            console.log(`${res}就是服务给我们返回的数据了`);
        }
    </script>
```
* 存在的问题：
    - JSONP只能处理GET请求； 
    - 不安全 
2、CORS 跨域资源共享
CORS实现跨域的关键是服务器，只要服务器实现了CORS接口，就可以实现跨域通信；服务器对于CORS的支持主要是通过给请求头header设置Access-Control-Allow-Origin属性，这个属性的作用是允许哪一个请求源请求。如果Access-Control-Allow-Origin设置了*，其含义就是允许所有的请求源请求。所以其实CORS实现跨域其实还是有弊端的

* 存在的问题：
    - 只能设置一个源； 
    - 如果ccess-Control-Allow-Origin设置了* ，会不安全

3、基于http代理实现跨域请求
主要是通过webpack webpack-dev-serve 在
4、nginx反向代理=>不需要客户端做处理
5、基于postMessage实现跨域处理
6、基于iframe的跨域解决方案
7、webSocket


http的缓存的了解
缓存的原理
请求头有哪些
服务端返回码有哪些，304代表什么意思
vue是怎么监听数组改变更新视图的 --- 浅薄的说了下
diff算法的实现 --- 有点亏，上一题回答的时候飙出来的词
怎么禁止js读取到cookie
移动端的对接和应用，怎么调用移动端的方法
### hooks 和 class Component 的区别
1、在写法上不同，hooks是用在函数组件上；而class Component是通过ES6 类的写法，通过定义一个类继承自React.Component。
2、在hooks中无法使用自定义的state对象，如果要使用state只能通过hooks的useState钩子去实现；但是在class Component 中直接可以通过this.state = {}这样的方式定一个state对象。
3、在hooks中不会存在this指向的问题；但是在class Component会频繁的用到this。这也是class Component相比于hooks的一个缺点。

### Vue 和 React 的区别
1、在实现方式上 --> React和Vue采用了截然不同的方法，Vue（2.X）中使用了options(选项) API；而React使用了（除了Hooks）是通过ES6中类的方式定义了一个组件。

注意：可能会问到options(选项) API
我们都知道Vue在初始化的时候是通过new Vue(options)的方式，这里会将options传入到Vue的构造函数中，这里的options包括component、props、data、methods、mounted等等，然后在Vue的构造函数中会初始化这些选项，比如data中我们定义的一些属性的初始化（这里主要是数据劫持）。

这里可能会被问到Vue 3.0的知识

2、在视图方面 --> 我们知道在Vue中使用了template（模版）这种形式，在实现方式上我们必须要遵循它的强规范，比如条件判断我们必须使用v-if、循环渲染必须使用 v-for、时间绑定必须使用@+事件名等等；而在React中不存在这些强规范，基本上都是按照原生的html 和 js 的写法（类名除外：className）。

3、数据响应方面 --> 我们知道在Vue中使用了数据双向绑定，也就是说数据改变可以驱动视图渲染，视图渲染可以驱动数据改变，比如我们在input组件中通过v-modal绑定data中的数据。在数据框中输入内容就可以直接修改data中的数据，不需要监听它的输入框的事件；但是React就不一样了，由于React是单向数据绑定，只能通过修改数据驱动视图，就拿input组件来说，我们必须要通过事件监听才能获取到输入的内容。

4、在使用上 --> 如果我们的项目结果比较复杂，数据交互比较繁琐，这时候我们应该考虑使用React；如果数据逻辑比较简单，可以考虑使用Vue;

### CSS盒模型
盒模型是指将HTML元素看作成为一个盒子，它主要包括外边距、内边距、边框、实际内容。盒模型主要有两种，分别是**标准盒模型**和**IE盒模型**。
**标准盒模型**是指盒子实际的宽度只是内容的宽度，不包含内边距和边框。比如我们给一个div设置宽度为300，border设置为10，padding设置为10，那实际真正的宽度是300。如果我们给内容设置了背景色，其实这个时候呈现在浏览器上的宽度为320，但是如果我们给这个元素这是点击事件，会发现只有中间宽度为300 的地方会触发这个事件，由此可见**标准盒模型**的宽度只包含实际内容的宽度。但是**IE盒模型**正好相反，它的盒子的实际宽度包含了内边距、边框的，所以**IE盒模型**的`width = border + padding + content`。

### 介绍一下flex布局
flex定义 --> flex是指弹性的意思，所以flex布局也叫弹性布局。flex布局的特点就是如果不给父元素设置固定宽高，那么父元素的宽高会被子元素动态的撑开。

在使用上 --> 我们可以通过display:flex 来设置flex布局，我们都知道，flex布局包括两条轴线，分别是主轴和交叉轴，这就类似于坐标系中的x轴和y轴。在flex布局中我们可以通过flex-direction属性来设置主轴的方向。flex-direction的取值有四个，分别是row、column、row-reverse、column-reverse；只有决定了主轴的方向，我们才能在flex布局中通过其他的一些属性来给元素设置布局样式。

一般情况下在移动端使用flex布局会比较多

### 介绍一下跨域
如何造成跨域 --> 跨域是指我们的请求违背了浏览器的**同源策略**。所谓的**同源**是指协议、端口号、ip三者都相同。和**同源**相对的**非同源**是指协议、端口号、ip有一个不同。如果**非同源**就会早晨跨域。（注意这里可能会问到什么情况下会早晨非同源）。举例来说：假如我有一个web页面部署在127.0.0.1:3000/地址上，在这个web页面中需要请求一些数据，而这些数据的服务是部署在127.0.0.1:8080服务器上，这个时候由于端口不一样就会造成跨域。

如何解决跨域问题 --> 一般情况下在开发中都是服务端来解决跨域问题，但是有时候也需要客户端来解决跨域问题。常用的解决解决跨域的方式有jsonp、cors（跨域资源共享）、nginx反向代理、nodejs中间件代理跨域、postMessage等等。

jsonp解决跨域主要是通过 `<script>` 标签的src属性，将我们要访问的接口地址拼接上callback参数通过GET方式，服务端接收到请求后将我们要访问的数据传递给我们拼接在url后的callback方法内，我们可以在前端定义callback方法用来接收和处理服务传给我们的数据。由于jsonp只能使用GET请求，所以使用jsonp解决跨域问题也是弊端的：第一、不安全，因为请求信息都是拼接在url当中的。第二、太局限了，因为只能使用在GET请求中。
